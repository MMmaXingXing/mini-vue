# 分节思路分析

## 22-实现初始化 Element 主流程

通过 createApp 进入,定义的 APP 配置项中的 render 函数 h，在初始化 Element 中可以被实现出来。

patch 中可以对渲染的元素的类型来进行区分，分为 Element 和 Component, 其中 Component 是由 Element 来进行组成的。我们可以对其进行拆箱，分别实现两个方法 processComponent 和 processElement。

二者主要的区别以 happypath 来定义，其 Component 一定为对象，Element 一定是 string 类型。

由此我们可知，所有的 Component 可以被继续拆分入 patch 进行细分。

processElement 中，会进行如下的推导。

processElement --> mountElementElement。

mountElement 中，我们会根据 h 方法的第一个入参 string 来创建 Dom 元素，创建完成后分别取 props 和 children 来对其进行处理。

props 进行遍历 setAttribute

children 通过类型来拆分，对象则递归进行拆箱处理，如果是字符串则创建对应元素且 append 到之前创建的元素中。

其中 children 的遍历处理部分可以重构抽离为 mountChildren 来进行深层次结构处理。

## 23-实现组件代理对象

代理对象在实际使用中常见方式有 this.mag, this.$el, this.$data 等形式。

我们在使用的时候可以使用 Proxy 代理对象来实现这种调用方式。

在创建有状态组件的时候，setupStatefulComponent 的时候我们可以创建一个代理对象。

然后在渲染的时候 instance.render()部分，即 steupRenderEffect 的时候将代理对象绑定到 render 的 this 上。

### 基本功能实现

接下来看代理对象的实现：

1. 如果 setupState 中存在对应的 key，则 return 此值

   其中 setupState 的来源我们可以在 setupStatefulComponent 的 setup 判断条件中找到在 handleSetupResult 中被赋值进了 instance

2. 创建完成 Proxy 后可以在 renderer 中 setupRenderEffect 的时候进行 this 指向的变更

至此，我们使用 this 的方式访问 setupState 的值就实现了

继续进行 $el 的实现：

$el 是 vue 的 API，作用是返回组件的根结点，root dom element

1. 要实现这个功能，我们需要先确认组件其根节点是在哪里被得到的，实例化的时候，我们会在 mountElement 中获取到其根节点，但是之前的实现我们并未对其进行任何操作

   因此接下来我们为 vnode 的 el 属性进行赋值

   然后在初始化虚拟节点的时候，我们要对 el 进行初始化

2. 接下来对 $el 进行处理

   在代理对象中对为 el 的 key 进行处理

最后我们要对刚刚实现的 el 功能进行调试，由于暂时我们还没有做事件初始化的处理，因此我们使用 window 变量挂载的方式来进行$el 参数的查看。

通过测试我们可以知道，window.self 实际上是没有值的，原因是因为 mountElement 部分的 el 实际是是 element 根节点的 el，不是组件的 el，因此接下来我们需要在 element 处理完之后，将根节点的 el 赋值给 组件 vnode 部分.

### 是否需要重构

1. 在 Proxy 实现的部分我们可能会有除了$el 之外的其他部分的处理 $data、$props..., 我们可以将 get 部分的变动点单独抽离出去。 由于处理需要使用到 instance，因此可以在 target 部分将 instance 作为目标值传入进去。

2. 我们可以看到 $el 的取值是通过 if 来取值的，但是由于后期我们还会有很多别的方式来进行处理，因此我们可以通过 map 的方式来对处理部分进行重构， 创建一个 publicPropertiesMap

3. vnode 在 mountComponent、setupRenderEffect 中可以变为 initnalVNode，增强代码可读性
