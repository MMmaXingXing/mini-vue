# 分节思路分析

## 22-实现初始化 Element 主流程

通过 createApp 进入,定义的 APP 配置项中的 render 函数 h，在初始化 Element 中可以被实现出来。

patch 中可以对渲染的元素的类型来进行区分，分为 Element 和 Component, 其中 Component 是由 Element 来进行组成的。我们可以对其进行拆箱，分别实现两个方法 processComponent 和 processElement。

二者主要的区别以 happypath 来定义，其 Component 一定为对象，Element 一定是 string 类型。

由此我们可知，所有的 Component 可以被继续拆分入 patch 进行细分。

processElement 中，会进行如下的推导。

processElement --> mountElementElement。

mountElement 中，我们会根据 h 方法的第一个入参 string 来创建 Dom 元素，创建完成后分别取 props 和 children 来对其进行处理。

props 进行遍历 setAttribute

children 通过类型来拆分，对象则递归进行拆箱处理，如果是字符串则创建对应元素且 append 到之前创建的元素中。

其中 children 的遍历处理部分可以重构抽离为 mountChildren 来进行深层次结构处理。

## 23-实现组件代理对象

代理对象在实际使用中常见方式有 this.mag, this.$el, this.$data 等形式。

我们在使用的时候可以使用 Proxy 代理对象来实现这种调用方式。

在创建有状态组件的时候，setupStatefulComponent 的时候我们可以创建一个代理对象。

然后在渲染的时候 instance.render()部分，即 steupRenderEffect 的时候将代理对象绑定到 render 的 this 上。

### 基本功能实现

接下来看代理对象的实现：

1. 如果 setupState 中存在对应的 key，则 return 此值

   其中 setupState 的来源我们可以在 setupStatefulComponent 的 setup 判断条件中找到在 handleSetupResult 中被赋值进了 instance

2. 创建完成 Proxy 后可以在 renderer 中 setupRenderEffect 的时候进行 this 指向的变更

至此，我们使用 this 的方式访问 setupState 的值就实现了

继续进行 $el 的实现：

$el 是 vue 的 API，作用是返回组件的根结点，root dom element

1. 要实现这个功能，我们需要先确认组件其根节点是在哪里被得到的，实例化的时候，我们会在 mountElement 中获取到其根节点，但是之前的实现我们并未对其进行任何操作

   因此接下来我们为 vnode 的 el 属性进行赋值

   然后在初始化虚拟节点的时候，我们要对 el 进行初始化

2. 接下来对 $el 进行处理

   在代理对象中对为 el 的 key 进行处理

最后我们要对刚刚实现的 el 功能进行调试，由于暂时我们还没有做事件初始化的处理，因此我们使用 window 变量挂载的方式来进行$el 参数的查看。

通过测试我们可以知道，window.self 实际上是没有值的，原因是因为 mountElement 部分的 el 实际是是 element 根节点的 el，不是组件的 el，因此接下来我们需要在 element 处理完之后，将根节点的 el 赋值给 组件 vnode 部分.

### 是否需要重构

1. 在 Proxy 实现的部分我们可能会有除了$el 之外的其他部分的处理 $data、$props..., 我们可以将 get 部分的变动点单独抽离出去。 由于处理需要使用到 instance，因此可以在 target 部分将 instance 作为目标值传入进去。

2. 我们可以看到 $el 的取值是通过 if 来取值的，但是由于后期我们还会有很多别的方式来进行处理，因此我们可以通过 map 的方式来对处理部分进行重构， 创建一个 publicPropertiesMap

3. vnode 在 mountComponent、setupRenderEffect 中可以变为 initnalVNode，增强代码可读性

## 24-实现 shapeFlages

shapeFlages 是描述当前虚拟节点的类型，用于描述当前节点是什么 flag

我们可以进行一个常规类型 flags 的设计

```javascript
const ShapeFlags = {
  element: 0,
  stateful_component: 0,
  text_children: 0,
  array_children: 0
};
```

这种形式下我们可以进行修改，同时也可以进行查找

```javascript
ShapeFlags.element = 1;

if (ShapeFlags.element)
```

上面的设计可以实现我们想要的功能，但是不太高效，我们可以使用位运算的方式来提效

flag 为 0000 四个位

```javascript

0001 -> element

0010 -> stateful

0100 -> text_children

1000 -> array_children

1010 --> stateful & array_children

```

同样我们这里需要进行修改，采用｜运算符

0000 ｜ 0001 === 0001

查找使用&运算符 &

0001 & 0001 === 0001

下面我们可以进行代码实现，在 shared 中创建一个 shapeFlag 的 ts 文件，并且创建一个 enum，按照位运算方式

同时在创建虚拟节点的部分定义一个 shapeFlag 的变量

将判断的枚举类型的业务逻辑在创建虚拟节点部分进行处理，同时实现一个 getShapeFlag 方法用于返回当前组件的类型，且在此对其 child 进行判断并设置进来。

将我们之前业务逻辑部分的 typeof 重构为 shapeFlag & 对应类型的模式对其进行类型的判断。

至此，shapeFlag 处理完毕
