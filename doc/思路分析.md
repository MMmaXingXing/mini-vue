# 分节思路分析

## 22-实现初始化 Element 主流程

通过 createApp 进入,定义的 APP 配置项中的 render 函数 h，在初始化 Element 中可以被实现出来。

patch 中可以对渲染的元素的类型来进行区分，分为 Element 和 Component, 其中 Component 是由 Element 来进行组成的。我们可以对其进行拆箱，分别实现两个方法 processComponent 和 processElement。

二者主要的区别以 happypath 来定义，其 Component 一定为对象，Element 一定是 string 类型。

由此我们可知，所有的 Component 可以被继续拆分入 patch 进行细分。

processElement 中，会进行如下的推导。

processElement --> mountElementElement。

mountElement 中，我们会根据 h 方法的第一个入参 string 来创建 Dom 元素，创建完成后分别取 props 和 children 来对其进行处理。

props 进行遍历 setAttribute

children 通过类型来拆分，对象则递归进行拆箱处理，如果是字符串则创建对应元素且 append 到之前创建的元素中。

其中 children 的遍历处理部分可以重构抽离为 mountChildren 来进行深层次结构处理。

## 23-实现组件代理对象

代理对象在实际使用中常见方式有 this.mag, this.$el, this.$data 等形式。

我们在使用的时候可以使用 Proxy 代理对象来实现这种调用方式。

在创建有状态组件的时候，setupStatefulComponent 的时候我们可以创建一个代理对象。

然后在渲染的时候 instance.render()部分，即 steupRenderEffect 的时候将代理对象绑定到 render 的 this 上。

### 基本功能实现

接下来看代理对象的实现：

1. 如果 setupState 中存在对应的 key，则 return 此值

   其中 setupState 的来源我们可以在 setupStatefulComponent 的 setup 判断条件中找到在 handleSetupResult 中被赋值进了 instance

2. 创建完成 Proxy 后可以在 renderer 中 setupRenderEffect 的时候进行 this 指向的变更

至此，我们使用 this 的方式访问 setupState 的值就实现了

继续进行 $el 的实现：

$el 是 vue 的 API，作用是返回组件的根结点，root dom element

1. 要实现这个功能，我们需要先确认组件其根节点是在哪里被得到的，实例化的时候，我们会在 mountElement 中获取到其根节点，但是之前的实现我们并未对其进行任何操作

   因此接下来我们为 vnode 的 el 属性进行赋值

   然后在初始化虚拟节点的时候，我们要对 el 进行初始化

2. 接下来对 $el 进行处理

   在代理对象中对为 el 的 key 进行处理

最后我们要对刚刚实现的 el 功能进行调试，由于暂时我们还没有做事件初始化的处理，因此我们使用 window 变量挂载的方式来进行$el 参数的查看。

通过测试我们可以知道，window.self 实际上是没有值的，原因是因为 mountElement 部分的 el 实际是是 element 根节点的 el，不是组件的 el，因此接下来我们需要在 element 处理完之后，将根节点的 el 赋值给 组件 vnode 部分.

### 是否需要重构

1. 在 Proxy 实现的部分我们可能会有除了$el 之外的其他部分的处理 $data、$props..., 我们可以将 get 部分的变动点单独抽离出去。 由于处理需要使用到 instance，因此可以在 target 部分将 instance 作为目标值传入进去。

2. 我们可以看到 $el 的取值是通过 if 来取值的，但是由于后期我们还会有很多别的方式来进行处理，因此我们可以通过 map 的方式来对处理部分进行重构， 创建一个 publicPropertiesMap

3. vnode 在 mountComponent、setupRenderEffect 中可以变为 initnalVNode，增强代码可读性

## 24-实现 shapeFlages

shapeFlages 是描述当前虚拟节点的类型，用于描述当前节点是什么 flag

我们可以进行一个常规类型 flags 的设计

```javascript
const ShapeFlags = {
  element: 0,
  stateful_component: 0,
  text_children: 0,
  array_children: 0
};
```

这种形式下我们可以进行修改，同时也可以进行查找

```javascript
ShapeFlags.element = 1;

if (ShapeFlags.element)
```

上面的设计可以实现我们想要的功能，但是不太高效，我们可以使用位运算的方式来提效

flag 为 0000 四个位

```javascript

0001 -> element

0010 -> stateful

0100 -> text_children

1000 -> array_children

1010 --> stateful & array_children

```

同样我们这里需要进行修改，采用｜运算符

0000 ｜ 0001 === 0001

查找使用&运算符 &

0001 & 0001 === 0001

下面我们可以进行代码实现，在 shared 中创建一个 shapeFlag 的 ts 文件，并且创建一个 enum，按照位运算方式

同时在创建虚拟节点的部分定义一个 shapeFlag 的变量

将判断的枚举类型的业务逻辑在创建虚拟节点部分进行处理，同时实现一个 getShapeFlag 方法用于返回当前组件的类型，且在此对其 child 进行判断并设置进来。

将我们之前业务逻辑部分的 typeof 重构为 shapeFlag & 对应类型的模式对其进行类型的判断。

至此，shapeFlag 处理完毕

## 25-实现事件注册功能

事件注册在使用中的方式是，在 h 函数的第二个参数中配置 eg：onClick 之类的方法来实现事件绑定，示例如下

```javascript
h(
  "div",
  {
    onClick() {}
  },
  "hi mini-vue"
);
```

进入到我们之前实现的 mountEvent，其中我们通过 for in 对 props 进行了处理

从功能上看，我们可以直接在 props 的部分进行判断处理，如果是 onClick 则 addEventListener

直接写进去代码如下

```javascript
if (val === "onClick") {
  el.addEventListener("click", val);
} else {
  el.setAttribute(key, val);
}
```

很明显以上是写死了的，接下来我们要继续进行下一项工作：“重构”

```javascript
const isOn = (key: string) => /^on[A~Z]/.test(key);
if (isOn(key)) {
  const event = key.slice(2).toLowerCase();
  el.addEventListener(event, val);
} else {
  el.setAttribute(key, val);
}
```

至此，事件处理部分结束，我们来回忆一下事件处理的流程

h --> patch --> processElement --> mountElement --> props 部分处理

## 26-实现组件 props 逻辑

从需求出发，在 vue 中我们的 props 是如何使用的呢？我们可以定义一个 Foo 的组件来实际走一下

```javascript
export const Foo = {
  render() {
    return h(
      "div",
      {
        id: "foo"
      },
      "foo: " + this.count
    );
  },
  setup(props) {
    // props.count
    console.log(props);
  }
};
```

由上我们可以理出来三个需求

1. props 会通过入参传入到 setup 方法中去
2. 通过 this 我们可以获取到 props 的值
3. props 是不可以被修改的，即 readonly。

setup 入参处理

我们需要先找到 setup 初始化的地方，我们组件是在 setupComponent 中处理的，我们在此处已经做了 setupStatefulComponent 的处理，在其中调用了 setup 方法，我们要在这里将 props 传入进去。

同理在 setupComponent 中进行 props 的处理，创建一个方法 initProps，在 componentProps 中定义，在 setupComponent 中进行调用初始化，实现单一职责处理。

上面处理可以使我们获取到 props

this 部分处理

我们找到之前对 setupState 进行处理的地方，同时将 props 进行处理即可

不可以修改处理

使用 shallowReadonly 来进行包裹处理

## 27-实现组件 emit 功能

vue3 中的 emit 是通过 setup 的第二个组件中的一个对象参数倒入进来的，类型是一个方法

```javascript
// 子组件
setup(props, {emit}) {
    emit("add")
}

// 父组件
h(“子组件”, {
    onAdd(){
        console.log("我被emit事件触发了");
    }
})
```

实现逻辑，我们根据当前 emit 中传入的参数来寻找当前 props 中是否有同名的函数，规则是 on + event 如果找到，则触发该函数

增加 instance.emit 并创建 componentEmit 文件来进行 emit 的实现

继续进行下一步，我们的 emit 如果需要传参我们应该怎么处理

```javascript
// 子组件
setup(props, {emit}) {
    emit("add", 1, 2);
}

// 父组件
h(“子组件”, {
    onAdd(a, b){
        console.log("我被emit事件触发了");
    }
})
```

再继续，允许用户使用“烤肉串的命名方式” --- add-foo

## 28-实现组件 slots 功能

如何使用插槽呢？

```javascript
// template 形式
<Foo>
  <p>12345</p>
</Foo>;

// h函数中使用
const foo = h(Foo, {}, h("p", {}, "slots 123"));
// Foo中实现
render() {
  return h("div", {}, [foo, this.$slots]);
}
```

需要实现功能，1. 单组件渲染， 2. 数组结构渲染

再其次，具名插槽的实现

需要两个点

1. 获取到要渲染的元素

2. 获取到要渲染的位置

作用域插槽的实现

最后部分可以在 initSlots 中判断是否有 children 或者 slots 类型，即是否需要 slots 处理

## 29-实现 Fragment 和 Text 类型节点

### 什么是 Fragment

我们之前遇见了子 slot 节点为数组的情况，解决方案是使用 div 进行包裹创建 createNode，但是这样子就造成我们多了一层元素。

因此我们继续分析，可以只渲染对应部分的 children，这就是 Fragment。

Fragmen 的实现的话，是在 vnode 中创建一个 Fragment 的 Symblo 类型，并且在 rander 中判断如果是 Fragment 类型则 processFragment 来处理自动渲染子节点。从而将数组类型的节点进行处理。

### Text 类型节点

同理 我们实现一个 Text 的 Symbol 的类型，同时创建一个 createTextVNode 用来对纯字符串类型进行处理转为虚拟节点，在 reander 中如果是 Text 类型则对应进行渲染。

## 30-实现 getCurrentInstance

这个 API 可以返回当前组件的实例对象，使用方式

```javascript
setup() {
  const internalInstance = getCurrentInstance(); // 只能在setup中来使用
}
```

实现我们只需要在 component 中创建一个 getCurrentInstance，在使用 setup 的时候，将 instance 赋值给全局变量并且对应 return 即可。

## 31-实现 provide-inject 功能

provide/inject 是一对组合 api，在父节点进行 provide 对应数据，子节点 inject 用来接收 provide 传过来的数据

即 存和取。我们新创建一个文件 apiInject.ts 用于创建两个 function provide 和 inject, 通过 getcurrentInstance 设置，通过 parent.providers 来获取。parent 在 render 的时候使用当前父亲元素的 instance。

provide: 这里存在一个问题，只能获取上层，但是实际上我们的需求是氟元素可以层层传递到最底层。

我们需要实现的话，可以和 js 中的原型链特性来进行搭配，当我们查找某值，但是查找不到的时候，js 会自动向上层对象的作用域链上来进行查找，层层递进，直到查到参数为止。

inject 还可以继续优化，一般我们 inject 的第二个参数是默认参数，我们可以来实现一下

如果 defaultValue 是 function，那么我们需要将 function 的运行值返回

## 32-实现 自定义渲染器(createReader) custom renderer

createReader：可以将 vdom 编译到不同的平台，不仅仅是 dom 结构

原理：我们将虚拟结构转换为真实结构是在 mountElement 中，我们直接创建了对应的元素

其中：

```javascript
// dom
document.createElement(vnode.type);
// canvas
new Element();

// dom
el.setAttribute(key, val);
// canvas
el[key] = val;

// dom
container.append(el);
// canvas
addChild();
```

已知我们之前的实现是固定写死，现在我们可以增加一个 createRenderer 来接收 options 来接收用户传入的参数，createElement、patchProp、insert 等

这部分由 runtime-dom 来进行管理，我们在 runtime-dom 中将这三个方法来进行定义

所有渲染 Dom 类型 API 统一由 runtime-dom 来管理，runtime-core 作为底层依赖引入到 runtime-dom 中
