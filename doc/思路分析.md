# 分节思路分析

## 22-实现初始化 Element 主流程

通过 createApp 进入,定义的 APP 配置项中的 render 函数 h，在初始化 Element 中可以被实现出来。

patch 中可以对渲染的元素的类型来进行区分，分为 Element 和 Component, 其中 Component 是由 Element 来进行组成的。我们可以对其进行拆箱，分别实现两个方法 processComponent 和 processElement。

二者主要的区别以 happypath 来定义，其 Component 一定为对象，Element 一定是 string 类型。

由此我们可知，所有的 Component 可以被继续拆分入 patch 进行细分。

processElement 中，会进行如下的推导。

processElement --> mountElementElement。

mountElement 中，我们会根据 h 方法的第一个入参 string 来创建 Dom 元素，创建完成后分别取 props 和 children 来对其进行处理。

props 进行遍历 setAttribute

children 通过类型来拆分，对象则递归进行拆箱处理，如果是字符串则创建对应元素且 append 到之前创建的元素中。

其中 children 的遍历处理部分可以重构抽离为 mountChildren 来进行深层次结构处理。

## 23-实现组件代理对象

代理对象在实际使用中常见方式有 this.mag, this.$el, this.$data 等形式。

我们在使用的时候可以使用 Proxy 代理对象来实现这种调用方式。

在创建有状态组件的时候，setupStatefulComponent 的时候我们可以创建一个代理对象。

然后在渲染的时候 instance.render()部分，即 steupRenderEffect 的时候将代理对象绑定到 render 的 this 上。

### 基本功能实现

接下来看代理对象的实现：

1. 如果 setupState 中存在对应的 key，则 return 此值

   其中 setupState 的来源我们可以在 setupStatefulComponent 的 setup 判断条件中找到在 handleSetupResult 中被赋值进了 instance

2. 创建完成 Proxy 后可以在 renderer 中 setupRenderEffect 的时候进行 this 指向的变更

至此，我们使用 this 的方式访问 setupState 的值就实现了

继续进行 $el 的实现：

$el 是 vue 的 API，作用是返回组件的根结点，root dom element

1. 要实现这个功能，我们需要先确认组件其根节点是在哪里被得到的，实例化的时候，我们会在 mountElement 中获取到其根节点，但是之前的实现我们并未对其进行任何操作

   因此接下来我们为 vnode 的 el 属性进行赋值

   然后在初始化虚拟节点的时候，我们要对 el 进行初始化

2. 接下来对 $el 进行处理

   在代理对象中对为 el 的 key 进行处理

最后我们要对刚刚实现的 el 功能进行调试，由于暂时我们还没有做事件初始化的处理，因此我们使用 window 变量挂载的方式来进行$el 参数的查看。

通过测试我们可以知道，window.self 实际上是没有值的，原因是因为 mountElement 部分的 el 实际是是 element 根节点的 el，不是组件的 el，因此接下来我们需要在 element 处理完之后，将根节点的 el 赋值给 组件 vnode 部分.

### 是否需要重构

1. 在 Proxy 实现的部分我们可能会有除了$el 之外的其他部分的处理 $data、$props..., 我们可以将 get 部分的变动点单独抽离出去。 由于处理需要使用到 instance，因此可以在 target 部分将 instance 作为目标值传入进去。

2. 我们可以看到 $el 的取值是通过 if 来取值的，但是由于后期我们还会有很多别的方式来进行处理，因此我们可以通过 map 的方式来对处理部分进行重构， 创建一个 publicPropertiesMap

3. vnode 在 mountComponent、setupRenderEffect 中可以变为 initnalVNode，增强代码可读性

## 24-实现 shapeFlages

shapeFlages 是描述当前虚拟节点的类型，用于描述当前节点是什么 flag

我们可以进行一个常规类型 flags 的设计

```javascript
const ShapeFlags = {
  element: 0,
  stateful_component: 0,
  text_children: 0,
  array_children: 0
};
```

这种形式下我们可以进行修改，同时也可以进行查找

```javascript
ShapeFlags.element = 1;

if (ShapeFlags.element)
```

上面的设计可以实现我们想要的功能，但是不太高效，我们可以使用位运算的方式来提效

flag 为 0000 四个位

```javascript

0001 -> element

0010 -> stateful

0100 -> text_children

1000 -> array_children

1010 --> stateful & array_children

```

同样我们这里需要进行修改，采用｜运算符

0000 ｜ 0001 === 0001

查找使用&运算符 &

0001 & 0001 === 0001

下面我们可以进行代码实现，在 shared 中创建一个 shapeFlag 的 ts 文件，并且创建一个 enum，按照位运算方式

同时在创建虚拟节点的部分定义一个 shapeFlag 的变量

将判断的枚举类型的业务逻辑在创建虚拟节点部分进行处理，同时实现一个 getShapeFlag 方法用于返回当前组件的类型，且在此对其 child 进行判断并设置进来。

将我们之前业务逻辑部分的 typeof 重构为 shapeFlag & 对应类型的模式对其进行类型的判断。

至此，shapeFlag 处理完毕

## 25-实现事件注册功能

事件注册在使用中的方式是，在 h 函数的第二个参数中配置 eg：onClick 之类的方法来实现事件绑定，示例如下

```javascript
h(
  "div",
  {
    onClick() {}
  },
  "hi mini-vue"
);
```

进入到我们之前实现的 mountEvent，其中我们通过 for in 对 props 进行了处理

从功能上看，我们可以直接在 props 的部分进行判断处理，如果是 onClick 则 addEventListener

直接写进去代码如下

```javascript
if (val === "onClick") {
  el.addEventListener("click", val);
} else {
  el.setAttribute(key, val);
}
```

很明显以上是写死了的，接下来我们要继续进行下一项工作：“重构”

```javascript
const isOn = (key: string) => /^on[A~Z]/.test(key);
if (isOn(key)) {
  const event = key.slice(2).toLowerCase();
  el.addEventListener(event, val);
} else {
  el.setAttribute(key, val);
}
```

至此，事件处理部分结束，我们来回忆一下事件处理的流程

h --> patch --> processElement --> mountElement --> props 部分处理

## 26-实现组件 props 逻辑

从需求出发，在 vue 中我们的 props 是如何使用的呢？我们可以定义一个 Foo 的组件来实际走一下

```javascript
export const Foo = {
  render() {
    return h(
      "div",
      {
        id: "foo"
      },
      "foo: " + this.count
    );
  },
  setup(props) {
    // props.count
    console.log(props);
  }
};
```

由上我们可以理出来三个需求

1. props 会通过入参传入到 setup 方法中去
2. 通过 this 我们可以获取到 props 的值
3. props 是不可以被修改的，即 readonly。

setup 入参处理

我们需要先找到 setup 初始化的地方，我们组件是在 setupComponent 中处理的，我们在此处已经做了 setupStatefulComponent 的处理，在其中调用了 setup 方法，我们要在这里将 props 传入进去。

同理在 setupComponent 中进行 props 的处理，创建一个方法 initProps，在 componentProps 中定义，在 setupComponent 中进行调用初始化，实现单一职责处理。

上面处理可以使我们获取到 props

this 部分处理

我们找到之前对 setupState 进行处理的地方，同时将 props 进行处理即可

不可以修改处理

暂略
